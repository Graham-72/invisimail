<?php
// $Id$

define('INVISIMAIL_MAILTO_ASCII', '&#109;&#97;&#105;&#108;&#116;&#111;&#58;');

/**
 * @file
 * This module provides a filter that will search content for email addresses
 * and replace them with their ascii equivalents before display. This is not
 * a complete protection from spam harvesters, but it is some help.
 */

/**
 * Implementation of hook_help().
 *
 */
function invisimail_help($section) {
  switch ($section) {
    case 'admin/help#invisimail':
      return t('<p>The invisimail module privides a filter to hide email addresses from email harvesting spam-bots.</p><p>How it works: Invisimail scans content for email addresses and then converts each character of the address to its ASCII-code equivalent. The email address will appear normally on the page, but the source html will not appear as an email address. For even more security, the filter can use a JavaScript write command to further obscure the email address.</p><p>For example:<br /><i>you@example.com</i> will appear in the html source as: <div style="font-family:courier;border:1px solid #666;padding: 5px">&amp;#121;&amp;#111;&amp;#117;&amp;#64;&amp;#101;&amp;#120;&amp;#97;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;</div></p><p>With the JavaScript and Auto-link options enabled, the source would become: <div style="font-family:courier;border:1px solid #666;padding: 5px">&lt;script type=\'text/javascript\'&gt;&lt;!--<br />
document.write(\'&lt;a href= "&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;\' + \'&amp;#121;&amp;#111;&amp;#117;&amp;#64;\' + \'&amp;#101;&amp;#120;&amp;#97;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#46;\' + \'&amp;#99;&amp;#111;&amp;#109;\' + \'"&gt;\' + \'&amp;#121;&amp;#111;&amp;#117;&amp;#64;\' + \'&amp;#101;&amp;#120;&amp;#97;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#46;\' + \'&amp;#99;&amp;#111;&amp;#109;\' + \'&lt;/a&gt;\');<br />
//--&gt;<br />
&lt;/script&gt;</div></p><p>Doesn\'t look like an email address, does it?</p><p>Of course the best protection against spam-bots is to not publish an email address at all, but on a community site some users are going to publish email addresses. Invisimail provides another level of security to keep them from recieving spam.</p><p>To configure Invisimail, select "configure" next to the <a href="%url">input format</a> you\'d like to use. Enable "Encode Email Addresses" and submit the form. Then select the "configure" tab to choose options for Invisimail.</p>', array('%url' => url('admin/filters')));
  }
}

/**
 * Implementation of hook_menu();
 */
function invisimail_menu() {

  $items = array();

  // This configuration page only really makes sense if you have email field installed.
  if (module_exists('email')) {
    $items['admin/settings/invisimail'] = array(
      'title' => t('Invisimail formatter'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('invisimail_formatter_settings'),
      'access arguments' => array('administer invisimail formatter'),
      'type' => MENU_NORMAL_ITEM,
    );
  }

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @todo This probably goes away once we convert to formatter settings API.
 */
function invisimail_permission() {
    return array(
    'administer invisimail formatter' =>  array(
      'title' => t('Administer invisimail formatter settings'),
    ),
  );
}

/**
 * Implements hook_invisimail_encoder_info().
 */
function invisimail_invisimail_encoder_info() {

  $encoders['html_entities'] = array(
    'label' => t('HTML entities'),
    'settings callback' => 'invisimail_encoder_html_entities_settings',
    'encode callback' => 'invisimail_encoder_html_entities_encode',
  );

  return $encoders;

}

/**
 * Gets a list of all encoders defined in the system.
 *
 * Encoders are defined by hook_invisimail_encoder_info() and use nearly the
 * same keys as filter definitions.  The main difference is the "label" key is
 * used in place of "title" to avoid confusion.  All callbacks will be called
 * from common callbacks defined by invisimail.
 *
 * @return array
 *   An array of all defined encoders.
 */
function invisimail_get_encoders() {

  $encoders = &drupal_static(__FUNCTION__, array());

  if (empty($encoders)) {
    $encoders = module_invoke_all('invisimail_encoder_info');
    foreach (array_keys($encoders) as $encoder) {
      $encoders[$encoder] += array(
        'settings callback' => '',
        'prepare callback' => '',
        'encode callback' => '',
        'default settings' => array('link' => 0),
      );
    }
    drupal_alter('invisimail_encoder_info', $encoders);
  }
  
  return $encoders;
}

/**
 * Gets the definition of the specified encoder.
 *
 * @param string $encoder
 *   The machine name of the encoder to load.
 * @return
 *   An encoder definition array or NULL if not found.
 */
function invisimail_get_encoder($encoder) {
  $encoders = invisimail_get_encoders();
  return isset($encoders[$encoder]) ? $encoders[$encoder] : NULL;
}

/**
 * Implements hook_filter_info().
 */
function invisimail_filter_info() {

  $filters = array();

  foreach (invisimail_get_encoders() as $encoder => $encoder_info) {
    $filters['invisimail_encode_' . $encoder] = array(
      'title' => t('Encode email addresses: @label', array('@label' => $encoder_info['label'])),
      'description' => t('Email addresses will be obfuscated in the page source to reduce the chances of being harvested by spammers.'),
      'prepare callback' => 'invisimail_encode_prepare',
      'process callback' => 'invisimail_encode_process',
      'settings callback' => 'invisimail_encode_settings',
      'default settings' => array(
        'encoder' => $encoder,
        'chunk' => FALSE,
      ) + $encoder_info['default settings'],
      'tips callback' => 'invisimail_encode_tips',
    );
  }

  return $filters;
}

/**
 * Process callback for all invisimail encoders.
 *
 * This callback will route the text to be processed to the general processor,
 * which in turn will route individual email addresses to the appropriate encoder.
 */
function invisimail_encode_process($text, $filter, $format, $langcode, &$cache, $cache_id) {
  $encoder = invisimail_get_encoder($filter->settings['encoder']);

  $cache = FALSE;

  if (function_exists($encoder['encode callback'])) {
    return invisimail_process_emails($text, $encoder['encode callback'], $filter->settings);
  }
  elseif ($encoder['encode callback']) {
    // Process is required, so there's no default passthrough option here.
    watchdog('invisimail', 'Invalid encode callback: @callback', array('@callback' => $encoder['encode callback']));
    return $text;
  }
}

/**
 * Prepare callback for all invisimail encoders.
 *
 * This callback will route the text to the appropriate prepare callback for
 * the appropriate encoder. If one is not specified it will return the text
 * unaltered.
 */
function invisimail_encode_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {
  $encoder = invisimail_get_encoder($filter->settings['encoder']);

  if (function_exists($encoder['prepare callback'])) {
    return $encoder['prepare callback']($text, $filter, $format, $langcode, $cache, $cache_id);
  }
  elseif ($encoder['prepare callback']) {
    watchdog('invisimail', 'Invalid prepare callback: @callback', array('@callback' => $encoder['prepare callback']));
  }
  else {
    return $text;
  }
}

/**
 * Settings callback for all encoding filters.
 *
 * This callback will call encoder-specific filtering if appropriate.
 */
function invisimail_encode_settings($form, &$form_state, $filter, $format, $defaults) {
  $settings = array();

  $filter->settings += $defaults;

  $settings['chunk'] = array(
    '#type' => 'checkbox',
    '#title' => t('Break up text for filtering'),
    '#weight' => 5,
    '#default_value' => $filter->settings['chunk'],
    '#description' => t('Break up the text to be filtered into chunks with and
                          without anchor tags.  Selecting this option may slow
                          down the filtering of text slightly, but will provide
                          better error messages in the <em>Recent log entries</em>
                          should content not render as you expect it when there
                          are e-mail addresses to obfuscate.'),
  );


  $encoder = invisimail_get_encoder($defaults['encoder']);

  if (function_exists($encoder['settings callback'])) {
    $settings += $encoder['settings callback']($form, $form_state, $filter, $format, $defaults);
  }
  elseif ($encoder['settings callback']) {
    watchdog('invisimail', 'Invalid settings callback: @callback', array('@callback' => $encoder['settings callback']));
  }
  // If there was nothing specified, that's not an error and we just continue normally.

  return $settings;
}

function invisimail_encoder_html_entities_settings($form, &$form_state, $filter, $format, $defaults) {

  $filter->settings += $defaults;

  $settings['link'] = array(
    '#type' => 'checkbox',
    '#title' => t('Automatically create links from email addresses.'),
    '#default_value' => $filter->settings['link'],
    '#description' => t('Selecting "Automatically create links" will convert email addresses into a clickable "mailto:" link.'),
  );

  return $settings;
}



/**
 * Returns the "tips" help text for all invisimail encoders.
 */
function invisimail_encode_tips($filter, $format, $long = FALSE) {
  return t('Email addresses will be obfuscated in the page source to reduce the chances of being harvested by spammers.');
}

/**
 * Generates the two pattern matching regexes for finding email addresses.
 *
 * This is moved to a separate function for cleanliness, and because it's
 * a hugely complex regex that we want to be able to encapsulate separately.
 *
 * @return array
 */
function _invisimail_email_matching_regexes() {
  // The check for the user/name portion of the email address. This is
  // encapsulable regex that looks for at least one valid character (in most
  // cases, a space), preceded by one invalid character, followed by at least
  // one valid character.
  $valid_user_chars = 'a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\'';
  $user = "(?<![$valid_user_chars])[$valid_user_chars]+";
  // For the domain portion of an email addy, you can have a string domain,
  // an ipv4 address, or an ipv6 address. These three regex capture each of
  // those possibilities, respectively.
  $domain = '(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}';
  $ipv4 = '[0-9]{1,3}(?:\.[0-9]{1,3}){3}';
  $ipv6 = '[0-9a-fA-F]{1,4}(?:[0-9a-fA-F]{1,4}){7}';
  // Now we stick it all together into a generalized, encapsulated, portable,
  // and non-subitem-capturing (hence all the '(?:', which mark subpatterns as
  // non-capturing) regex for grabbing email addresses.
  $mail = "(?:$user)+\@(?:$domain|(?:\[(?:$ipv4|$ipv6)\]))";
  // PCRE pattern modifiers; 'i' enables case-insensitivity, and 'S' enables
  // the additional pattern analysis, as our regex is one that can benefit
  // (it is a non-anchored pattern without a single fixed starting character.
  // see http://us2.php.net/manual/en/reference.pcre.pattern.modifiers.php).
  // Global case insensitivity is a little sloppy to use, but selectively
  // toggling it within only some of the subpatterns isn't really worth the
  // effort.
  $modifiers = 'iS';
  // The final pattern. We deal with these as an entire group because invisimail
  // allows options that require us to deal with both an href and its text
  // in relation to one another.
  $pattern = "@(?:(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>)?((?".">(?<!mailto:))$mail))|(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>(.*?)</a>)@$modifiers";
  $pattern_diff_link_text = "@(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>(.*?)</a>)@$modifiers";
  $pattern_same_link_text = "@(?:(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>)?((?".">(?<!mailto:))$mail))@$modifiers";

  return array(
    'diff_link' => $pattern_diff_link_text,
    'same_link' => $pattern_same_link_text,
  );
}

function invisimail_process_emails($string, $callback, $settings = array()) {
  // PHP doens't allow preg callbacks to take arguments, so we have to toss
  // the configuration options into a global temporarily.  this is so disgusting.
  $settings['callback'] = $callback;
  $GLOBALS['invisimail_settings'] = $settings;

  $patterns = _invisimail_email_matching_regexes();

  // Chunking will help determine in which portion of the overall string a call
  // to preg_replace_callback may fail.
  if (isset($settings['chunk']) && $settings['chunk']) {
    $substrings = preg_split( '/(<a [^>]*>.+?<\/a>)/', $string, -1, PREG_SPLIT_DELIM_CAPTURE );
  }
  else {
    $substrings = array( $string );
  }

  $return = '';
  foreach ( $substrings as $phrase ) {
    // Call preg_replace_callback twice to avoid prolems with hitting the
    // backtrack limit, as the more complex $pattern has issues with domains more
    // than 13 characters.
    $replaced_phrase = preg_replace_callback($patterns['diff_link'], '_invisimail_process_emails_callback', $phrase);
    if ($error_code = preg_last_error()) {
      watchdog('invisimail', 'preg_replace_callback failed on first pass with preg_last_error() of !code with pattern %pattern on text: !text',
            array(
              '!code'=>$error_code,
              '%pattern' => check_plain($pattern_diff_link_text),
              '!text' => check_plain($phrase),
            ),
            WATCHDOG_ERROR,
            request_uri());
    }
    $replaced_phrase = preg_replace_callback($patterns['same_link'], '_invisimail_process_emails_callback', $replaced_phrase);
    if ($error_code = preg_last_error()) {
      watchdog('invisimail', 'preg_replace_callback failed on second pass with preg_last_error() of !code with pattern %pattern on text: !text',
            array(
              '!code'=>$error_code,
              '%pattern' => check_plain($pattern_same_link_text),
              '!text' => check_plain($phrase),
            ),
            WATCHDOG_ERROR,
            request_uri());
    }
    $return .= $replaced_phrase;
  }

  // Clean up our global.
  unset($GLOBALS['invisimail_settings']);

  return $return;
}

/**
 * Callback function used by preg_replace_callback.
 *
 * Expects the regex pattern defined in invisimail_process_emails() to be used.
 *
 * @param array $matches
 *  An array of matched patterns from our regex. Any match will have four keys,
 *  numbered 0-3, which correspond to the capturing groups in our regex. For all
 *  these examples, assume the following string:
 *  <p><a href="mailto:user@domain.com">user@domain.com</a></p>
 *    - 0: The entire matched string. This will include the email address, as
 *      well as that email address' corresponding href mailto iff it exists. In
 *      the example, it would be
 *        <a href="mailto:user@domain.com">user@domain.com
 *    - 1: The full string of the <a> tag portion of the match, iff that portion
 *      was matched; otherwise an empty string. In the example, it would be
 *        <a href="mailto:user@domain.com">
 *    - 2: The mailto + email address string from the href portion of the match,
 *      iff an href was found. In the example, it would be:
 *        mailto:user@domain.com
 *    - 3: The email address itself. In the example, just:
 *      user@domain.com
 *  for the next set of array elements, assume the following string:
 *  <p><a href="mailto:user@domain.com">click here to eMail</a></p>
 *    - 1: The entire matched string, but this time where the link text does not
 *      match the mailto address.  In the example, it would be
 *        <a href="mailto:user@domain.com">click here to eMail
 *    - 2:The mailto + email address string from the href portion of the match,
 *      iff an href was found. In the example, it would be:
 *        mailto:user@domain.com
 *    - 3: The link text. In the example, just:
 *      click here to eMail
 *
 * @return string
 *   The full ASCII-encoded string that will replace the entire match.
 */
function _invisimail_process_emails_callback(array $matches) {
  $settings = $GLOBALS['invisimail_settings'];

  // If $matches[1] is empty, no link portion was matched for this item, so
  // it's a simple replace operation.
  if (empty($matches[1])) {
    return $settings['callback']($matches[3], $settings);
    //return invisimail_ascii_encode($matches[3], $format['js'], $format['link']);
  }

  // If $matches[3] is something other than the eMail address, then we
  // matched on an <a> tag that didn't have the link text the same as the
  // mailto eMail address, so just replace the eMail address
  if ( $matches[2] != 'mailto:'.$matches[3] ) {
    return str_replace($matches[2], $settings['callback']($matches[2], $settings, TRUE), $matches[0]);
  }

  // We DO have an existing link portion. Do our best to preserve it; that means
  // ignoring the js setting, since it makes for heinous string transformations.
  return str_replace(array($matches[2], $matches[3]),
    array($settings['callback']($matches[2], $settings, TRUE), $settings['callback']($matches[3], $settings, TRUE)), $matches[0]);

}

function invisimail($string, $format) {
  // The check for the user/name portion of the email address. This is
  // encapsulable regex that looks for at least one valid character (in most
  // cases, a space), preceded by one invalid character, followed by at least
  // one valid character.
  $valid_user_chars = 'a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\'';
  $user = "(?<![$valid_user_chars])[$valid_user_chars]+";
  // For the domain portion of an email addy, you can have a string domain,
  // an ipv4 address, or an ipv6 address. These three regex capture each of
  // those possibilities, respectively.
  $domain = '(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}';
  $ipv4 = '[0-9]{1,3}(?:\.[0-9]{1,3}){3}';
  $ipv6 = '[0-9a-fA-F]{1,4}(?:[0-9a-fA-F]{1,4}){7}';
  // Now we stick it all together into a generalized, encapsulated, portable,
  // and non-subitem-capturing (hence all the '(?:', which mark subpatterns as
  // non-capturing) regex for grabbing email addresses.
  $mail = "(?:$user)+\@(?:$domain|(?:\[(?:$ipv4|$ipv6)\]))";
  // PCRE pattern modifiers; 'i' enables case-insensitivity, and 'S' enables
  // the additional pattern analysis, as our regex is one that can benefit
  // (it is a non-anchored pattern without a single fixed starting character.
  // see http://us2.php.net/manual/en/reference.pcre.pattern.modifiers.php).
  // Global case insensitivity is a little sloppy to use, but selectively
  // toggling it within only some of the subpatterns isn't really worth the
  // effort.
  $modifiers = 'iS';
  // The final pattern. We deal with these as an entire group because invisimail
  // allows options that require us to deal with both an href and its text
  // in relation to one another.
  $pattern = "@(?:(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>)?((?".">(?<!mailto:))$mail))|(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>(.*?)</a>)@$modifiers";
  $pattern_diff_link_text = "@(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>(.*?)</a>)@$modifiers";
  $pattern_same_link_text = "@(?:(<a [^>]*href=['\"](mailto:$mail)['\"][^>]*>)?((?".">(?<!mailto:))$mail))@$modifiers";

  // The callback needs to know about the filter we're using, but there's no way
  // to hand off that variable through preg_replace_callback. So we set it as a
  // global variable.
  $GLOBALS['invisimail_format'] = array(
    'js' => variable_get('invisimail_js_'.$format, FALSE),
    'link' => variable_get('invisimail_link_'.$format, FALSE),
  );

  // Chunking will help determin in which portino of the overall string a call
  // to preg_replace_callback may fail.
  if ( variable_get('invisimail_chunk_'.$format, TRUE) ) {
    $substrings = preg_split( '/(<a [^>]*>.+?<\/a>)/', $string, -1, PREG_SPLIT_DELIM_CAPTURE );
  }
  else {
    $substrings = array( $string );
  }
  $return = '';
  foreach ( $substrings as $phrase ) {
    // Call preg_replace_callback twice to avoid prolems with hitting the
    // backtrack limit, as the more complex $pattern has issues with domains more
    // than 13 characters.
    $replaced_phrase = preg_replace_callback($pattern_diff_link_text, 'invisimail_callback', $phrase);
    if ($error_code = preg_last_error()) {
      watchdog('invisimail', 'preg_replace_callback failed on first pass with preg_last_error() of !code with pattern %pattern on text: !text',
            array(
              '!code'=>$error_code,
              '%pattern' => check_plain($pattern_diff_link_text),
              '!text' => check_plain($phrase),
            ),
            WATCHDOG_ERROR,
            request_uri());
    }
    $replaced_phrase = preg_replace_callback($pattern_same_link_text, 'invisimail_callback', $replaced_phrase);
    if ($error_code = preg_last_error()) {
      watchdog('invisimail', 'preg_replace_callback failed on second pass with preg_last_error() of !code with pattern %pattern on text: !text',
            array(
              '!code'=>$error_code,
              '%pattern' => check_plain($pattern_same_link_text),
              '!text' => check_plain($phrase),
            ),
            WATCHDOG_ERROR,
            request_uri());
    }
    $return .= $replaced_phrase;
  }

  return $return;
}

/**
 * Callback function used by preg_replace_callback.
 *
 * Expects the regex pattern defined in invisimail() to be used.
 *
 * @param array $matches
 *  An array of matched patterns from our regex. Any match will have four keys,
 *  numbered 0-3, which correspond to the capturing groups in our regex. For all
 *  these examples, assume the following string:
 *  <p><a href="mailto:user@domain.com">user@domain.com</a></p>
 *    - 0: The entire matched string. This will include the email address, as
 *      well as that email address' corresponding href mailto iff it exists. In
 *      the example, it would be
 *        <a href="mailto:user@domain.com">user@domain.com
 *    - 1: The full string of the <a> tag portion of the match, iff that portion
 *      was matched; otherwise an empty string. In the example, it would be
 *        <a href="mailto:user@domain.com">
 *    - 2: The mailto + email address string from the href portion of the match,
 *      iff an href was found. In the example, it would be:
 *        mailto:user@domain.com
 *    - 3: The email address itself. In the example, just:
 *      user@domain.com
 *  for the next set of array elements, assume the following string:
 *  <p><a href="mailto:user@domain.com">click here to eMail</a></p>
 *    - 1: The entire matched string, but this time where the link text does not
 *      match the mailto address.  In the example, it would be
 *        <a href="mailto:user@domain.com">click here to eMail
 *    - 2:The mailto + email address string from the href portion of the match,
 *      iff an href was found. In the example, it would be:
 *        mailto:user@domain.com
 *    - 3: The link text. In the example, just:
 *      click here to eMail
 *
 * @return string
 *   The full ASCII-encoded string that will replace the entire match.
 */
function invisimail_callback($matches) {
  $format = $GLOBALS['invisimail_format'];

  // If $matches[1] is empty, no link portion was matched for this item, so
  // it's a simple replace operation.
  if (empty($matches[1])) {
    return invisimail_ascii_encode($matches[3], $format['js'], $format['link']);
  }

  // If $matches[3] is something other than the eMail address, then we
  // matched on an <a> tag that didn't have the link text the same as the
  // mailto eMail address, so just replace the eMail address
  if ( $matches[2] != 'mailto:'.$matches[3] ) {
    return str_replace($matches[2], _invisimail_encode_string($matches[2], FALSE),
          $matches[0]);
  }
  
  // We DO have an existing link portion. Do our best to preserve it; that means
  // ignoring the js setting, since it makes for heinous string transformations.
  return str_replace(array($matches[2], $matches[3]),
    array(_invisimail_encode_string($matches[2], FALSE), _invisimail_encode_string($matches[3], FALSE)),
    $matches[0]);
}

function invisimail_encode_add_link($string, $js, $text) {
  static $counter = 0;
  $encode = _invisimail_encode_string($string, $js);

  $text = is_null($text) ? $encode : $text;

  if ($js) {
      $linkId = md5("mailto_link_{$counter}");
      $counter ++;
      $output = "<span id=\"$linkId\"></span>";
      $output .="
            <script type=\"text/javascript\" > <!--
        document.getElementById('$linkId')
                .innerHTML = '<a href=\"" . INVISIMAIL_MAILTO_ASCII . "'+'$encode'+'\">'+'"
                . $text . "' + '</a>';"
      ."\n // --> </script>";
  }
  else {
    $output = '<a href="' . INVISIMAIL_MAILTO_ASCII . "$encode\">$text</a>";
  }
  return $output;
}

/**
 * ASCII-encode an email address.
 *
 * @param $string
 *   A string containing _only_ an email address to be encoded.
 * @param $js
 *   Optional: A boolean which sets whether Javascript is used for encoding.
 * @param $link
 *   Optional: A boolean which set whether the result includes a mailto link.
 * @param $text
 *   Optional: The text to be used for the link.
 * @return
 *   An ascii encoded email address, optionally with link included.
 */
function invisimail_ascii_encode($string, $js = FALSE, $link = FALSE, $text = NULL) {
  return $link ? invisimail_encode_add_link($string, $js, $text) : _invisimail_encode_string($string, $js, $link);
}

/**
 * Performs ASCII encoding on the provided string.
 *
 * @param string $string
 * @param bool $js
 * @return string
 */
function _invisimail_encode_string($string, $js, $link = FALSE) {
  $encode = '';
  for ($i=0; $i < strlen($string); $i++)   {
    $char = substr($string, $i, 1);
    $encode .= '&#'.ord($char).';';
    if ($js && $link) {
      if (in_array($char, array('.', '@'))) {
      // break strings after ats and dots.
        $encode .= "'+'";
      }
    }
  }
  return $encode;
}

function invisimail_encoder_html_entities_encode($string, $settings = array(), $is_link = FALSE) {
  $encode = '';
  for ($i=0; $i < strlen($string); $i++)   {
    $char = substr($string, $i, 1);
    $encode .= '&#'.ord($char).';';
  }

  if ($settings['link'] && !$is_link) {
    $encode = '<a href="' . INVISIMAIL_MAILTO_ASCII . "$encode\">$encode</a>";
  }

  return $encode;
}

/**
 * Implementation of hook_field_formatter_info(),.
 */
function invisimail_field_formatter_info() {
  return array(
    'invisimail' => array(
      'label' => t('Encode with Invisimail'),
      'field types' => array('email'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}

/**
 * Implementation of hook_theme().
 */
function invisimail_theme() {
  return array(
    'invisimail_formatter_invisimail' => array(
      'arguments' => array(
        'element' => NULL,
      ),
    ),
  );
}

function theme_invisimail_formatter_invisimail($element) {

  // If there's no email address, don't bother trying to encode it.
  if ($element['#item']['email'] == '') {
    return;
  }

  if (module_exists('invisimail')) {
    return invisimail_ascii_encode($element['#item']['email'], variable_get('invisimail_js_formatter', 0), variable_get('invisimail_link_formatter', 0));
  }
  else {
    return '<a href="mailto:'. $element['#item']['email'] .'">'. check_plain($element['#item']['email']) .'</a>';
  }
}

/**
 * Settings form for the invisimail CCK formatter.
 *
 */
function invisimail_formatter_settings() {
  return system_settings_form(_invisimail_settings('formatter'));
}

/**
 * Helper function for the invisimail configuration form.
 *
 * @param $format
 *   The key of the format we are defining a setting for.  For the CCK formatter,
 *   this will be "formatter".  For input filters, it will be an integer.
 * @return A form fragment.
 */
function _invisimail_settings($format) {
  $form['invisimail_js_'. $format] = array(
    '#type' => 'radios',
    '#title' => t('JavaScript'),
    '#default_value' => variable_get('invisimail_js_'. $format, 0),
    '#options' => array(0 => t('No JavaScript - greater compatibility'), 1 => t('Use JavaScript - greater security')),
    '#description' => t('Selecting "Use JavaScript" will nearly guarantee protection from spam harvesters. However email addresses will not appear for browsers without JavaScript capability.'),
  );

  $form['invisimail_link_'. $format] = array(
    '#type' => 'radios',
    '#title' => t('Auto-link Emails'),
    '#default_value' => variable_get('invisimail_link_'. $format, 0),
    '#options' => array(0 => t('Do not create links.'), 1 => t('Automatically create links from email addresses.')),
    '#description' => t('Selecting "Automatically create links" will convert email addresses into a clickable "mailto:" link.'),
  );
  
  $form['invisimail_chunk_'. $format] = array(
    '#type' => 'checkbox',
    '#title' => t('Break up text for filtering'),
    '#default_value' => variable_get( 'invisimail_chunk_'. $format, TRUE ),
    '#description' => t('Break up the text to be filtered into chunks with and
                          without anchor tags.  Selecting this option may slow
                          down the filtering of text slightly, but will provide
                          better error messages in the <em>Recent log entries</em>
                          should content not render as you expect it when there
                          are e-mail addresses to obfuscate.'),
  );

  return $form;
}
